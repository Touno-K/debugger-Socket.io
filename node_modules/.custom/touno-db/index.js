const Q 				= require('q');
const mysql 		= require('mysql');
const mysqlWrap = require('mysql-wrap');
const config 		= require('.custom/config');
const mongoose 	= require('mongoose');

var db_mysql = {
  connect: function(cn) {
    cn = cn || {};
    const pool = mysql.createPool({
      connectionLimit: cn.connLimit || config.mysql.connLimit || 10000,
      host: cn.host || config.mysql.host || 'localhost',
      port: cn.port || config.mysql.port || 3306,
      database: cn.database || config.mysql.database || 'mysql',
      user: cn.user || config.mysql.user || 'root',
      password: cn.password || config.mysql.password || '',
      debug: cn.debug || config.mysql.debug || false,
      supportBigNumbers: true,
      timezone:'+7:00',
      dateStrings:true,
      queryFormat: function (query, values) {
        if (!values) {
          return query;
        }
        return query.replace(/\:(\w+)/g, function (txt, key) {
          if (values.hasOwnProperty(key)) {
            return this.escape(values[key]);
          }
          return txt;
        }.bind(this));
      }
    });
    return mysqlWrap(pool);
  }
}

const SchemaCommitSince = mongoose.Schema({
  commit_id: String,
  user_id: String,
  repository: String,
  since: String
});

const SchemaCommits = mongoose.Schema({
  repository: String,
  logs: [{ 
  	commit: String, 
  	author: String,
  	comment: String,
  	since: String
  }]
});

const SchemaClient = mongoose.Schema({
  username: String,
});

mongoose.connect(config.mongoose);
var db = {
	CommitSince: mongoose.model('logs_commits_since', SchemaCommitSince),
	Commits: mongoose.model('logs_commits', SchemaCommits),
	Commits: mongoose.model('logs_clients', SchemaClient),
}

var db_mongo = {
	commiter: {
		select: function(user_id, repository) {
	    var def = Q.defer();
			db.CommitSince.findOne({ 'user_id': user_id, 'repository': repository }, '', function(err, commit) {
			  if (err) {
			  	def.resolve(undefined);
			  } else {
			  	def.resolve(commit);
			  }
			});
			//def.resolve({});
	    return def.promise;
		},
		update: function(user_id, repository, since_date) {
	    var def = Q.defer();
			db.CommitSince.findOne({'user_id':user_id,'repository':repository}, '', function(err, commit) {
			  if (!err && commit) {
					db.CommitSince.update({user_id:user_id,repository:repository},{since:since_date}, function(err) {
					  def.resolve(err?false:true);
					});
			  } else {
					var since = new db.CommitSince({'user_id':user_id,'repository':repository,'since':since_date});
					since.save(function (err, since) {
					  console.log(err?false:true);
						def.resolve();
					});
			  }
			});
	    return def.promise;
		}
	},
	log: {
		save: function(repository, logs){
	  //   var def = Q.defer();
			// db.Commits.findOne({repository:repository}, '', function(err, commit) {
			//   if (!err && commit) {
			// 		db.Commits.update({repository:repository}, {$push:{logs:{$each:logs}}}, {upsert:true}, function(err){
		 //        def.resolve(err?false:true);
			// 		});
			//   } else {
			// 		var log = new db.Commits({ 'repository': repository, 'logs': logs });
			// 		log.save(function (err, log) {
			// 			def.resolve(err?false:true);
			// 		}); 
			//   }
			// });
	  //   return def.promise;
		},
		getLast: function(){

		}
	}
}


// function(schema){

// 	var silence = new Kitten({ name: 'Silence' });
// 	console.log(silence.name); // 'Silence'

// 	silence.save(function (err, silence) {
// 	  if (err) return console.error(err);
// 		console.log(silence); // 'Silence'
	  
// 	});


// 	// Kitten.find(function (err, kittens) {
// 	//   if (err) return console.error(err);
// 	//   console.log(kittens);
// 	// })

// }

module.exports = {
	mysql: db_mysql,
	mongo: db_mongo
}